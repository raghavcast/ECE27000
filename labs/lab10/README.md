# State Machines

## Instructional Objectives

- To practice construction of state machines with behavioral Verilog.
- To practice construction of structural state machines with discrete logic.

## Introduction

In this lab experiment, you will practice building a non-trivial state machine with a next-state table. This lab builds on concepts you've learned and practiced in previous exercises. In particular, the determination of the next-state equations from a next-state table will require some thought to understand how to implement them. The prelab assignment will lead you through this process and check your work.

The state machine you are to build will be uniquely generated for you. You will find the specifications for the machine in the prelab assignment. You will simulate the circuit with Verilog and become familiar with its operation.

When you build the circuit, you will use concepts that have been discussed in lecture. You will verify the operation of a typical edge-triggered D flip-flop, specify similar circuits using Verilog to try on the FPGA simulator, and with the understanding of the sequential logic devices discussed, implement a ring counter with Verilog and again with discrete logic.

## Step 0: Prelab

This lab is about implementing an arbitrary sequential state machine. The state machine you will build has *three bits of state*. This will be represented by three flip-flops that share the same clock. A *reset* signal will be connected to either the asynchronous *preset* or *clear* input of each flip-flop to force the state of the system to a particular three-bit value. For the actual lab experiment, you will use the following components:
- (2) [74HC74](https://engineering.purdue.edu/ece270/refs/74hc74.pdf) dual D-type flip-flops with asynchronous preset and clear
- (1) [74HC138](https://engineering.purdue.edu/ece270/refs/74hc138.pdf) 3-to-8 decoder with active-low outputs
- (1) [74HC10](https://engineering.purdue.edu/ece270/refs/74hc10.pdf) triple 3-input NAND gate
- (1) [74HC08](https://engineering.purdue.edu/ece270/refs/74hc08.pdf) quad 2-input AND gate
- (1) [74HC14](https://engineering.purdue.edu/ece270/refs/74hc14.pdf) hex Schmitt-trigger inverter

For the prelab, you will model the work with Verilog.

### Implementing the next-state logic

Recall the diagram of a Moore-model state machine.

<p align=center>
  <img src="https://user-images.githubusercontent.com/37441514/160920907-88d3f1c3-fede-4682-9880-f7e6a9610dfa.png" alt="Moore state machine" width=600>
</p>

For the next-state logic there will be no external inputs. The next state will depend only on the three bits of the current state. An easy way to implement a three-variable logic function is to use a 3-to-8 decoder. When the decoder has active-low outputs, the inverted minterms can be summed with NAND gates. This is very similar to what you did for lab 5 when you implemented eight unique logic functions.

Implement these functions in the **top** module of your design as follows:

- Represent the state with a three-bit logic bus named 'q'.
- Represent the "next-state" with a three-bit logic bus named 'next_q'.
- Rather than using discrete structural flip-flops, use an **always_ff** block to update the 'q' bus as follows:
    - Use pb[1] as an asynchronous reset signal. It should set the state of the three flip-flops to the value specified below. As long as pb[1] is asserted, the state of the flip-flops will retain this value regardless of the actions of the clock signal.
    - Use pb[0] as a clock signal. As long as pb[1] is not asserted, it should set the 'q' logic bus to 'next_q'.
- Add the [SystemVerilog model of the 74HC138](https://engineering.purdue.edu/ece270/refs/hc138.sv) to your design. Create one instance of it, connect its 'a' inputs to the state 'q', and wire its 'e' enable pins to allow exactly one of its outputs to be active all the time. Connect an 8-bit logic bus named 'p' (product terms) to the 'y' output of the decoder.
- Connect each of the three elements of the 'next_q' bus to the output of a four-input dataflow NAND expression. Each input of the NAND will be one of the elements of the 'p' bus — the inverted product terms generated by the decoder.
- Connect the 'q' bus to right[2:0] for observation.
- Connect the 'next_q' bus to left[2:0] for observation.

The output logic for this Moore machine will be only a straight "pass-through" of all three 'q' values.

Your **top** module should look something like this:
```
module top(...);  
    logic [2:0] q;  
    logic [2:0] next_q; 
    always_ff @( ... )
        ...
    logic [7:0] p;
    hc138 decode(.a(q), .e1(0), .e2(0), .e3(1), .y(p));
    assign next_q[0] = ...
    assign next_q[1] = ...
    assign next_q[2] = ...
    assign right[2:0] = ...
    assign left[2:0] = ...
endmodule
```

### Your next-state function and reset value

Just as with lab 5, you will implement a unique next-state block (and reset value) for your design. Your next-state table is as follows:

<table>
  <thead>
    <th align=center><b>q</b></th>
    <th algin=center><b>next_q</b></th>
  </thead>
  <tbody>
    <tr>
      <td align=center>0</td>
      <td align=center>6</td>
    </tr>
    <tr>
      <td align=center>1</td>
      <td align=center>5</td>
    </tr>
    <tr>
      <td align=center>2</td>
      <td align=center>7</td>
    </tr>
    <tr>
      <td align=center>3</td>
      <td align=center>2</td>
    </tr>
    <tr>
      <td align=center>4</td>
      <td align=center>3</td>
    </tr>
    <tr>
      <td align=center>5</td>
      <td align=center>4</td>
    </tr>
    <tr>
      <td align=center>6</td>
      <td align=center>1</td>
    </tr>
    <tr>
      <td align=center>7</td>
      <td align=center>0</td>
    </tr>
  </tbody>
</table>

**your reset value is 5**

Test your system. Ensure that holding down the '1' button immediately forces the 'q' state to the reset value shown above. As long as the '1' button is pressed, 'q' should remain set to the reset value regardless of the activity on the clock. When the '1' button is released, each press of the '0' button should immediately cause 'q' to change to 'next_q'. Pressing the '0' button eight times will follow one full cycle of the state back to the starting value.

### Step 0.1: Implement the next-state equations 

Normally, you would write next-state logic by creating an **always_comb** block to hold a **case** statement that sets up the mapping from inputs to outputs. This prelab is meant to get you ready to understand and wire a circuit that you can test in the real world. Fill in the Verilog dataflow elements for the next_q Let's get started by writing the equations, using Verilog dataflow syntax, for each of your next_q elements, in terms of the **p** bus elements. For instance, if you wanted set next_q[0] to 1 whenever the q[2:0] is 0, 1, 2, or 3, you would say something like this:

```
assign next_q[0] = ~( p[0] & p[1] & p[2] & p[3] );
```

## Step 1: Build a state machine

<p align=center>
  <img src="https://user-images.githubusercontent.com/37441514/160922412-19754b0a-fef0-4a38-8fd0-48104e2712a1.png" alt="state machine scematic" width=600>
</p>

Consider the schematic diagram above, which represents the basic outline of the circuit you will construct. Some parts are intentionally left open because they will be unique to your state machine specifications. In particular:

- The connections between the outputs of the 74HC138 and the inputs to the AND-gates and NAND-gates must be determined for your specific state machine.
- There is a strange-looking graphic around the set and reset connections to each flip-flop. This is to indicate that the ResetN signal should be connected to exactly one of the set or reset inputs of each individual flip-flop. The other input should be connected to a 1KΩ resistor to VDD. A series 1KΩ resistor is recommended here, rather than connecting the input directly to VDD. This prevents damage in the even that you accidentally connect a flip-flop output to VDD. As long as you are careful, you may simply connect either the set or reset to VDD directly. The strange graphic represents a crossover switch, but you will simply choose the appropriate permanent connections to implement setting the reset value for your state machine.
<p align=center>
  <img src="https://user-images.githubusercontent.com/37441514/160922607-72d2a5c7-d1cd-4b86-8f64-1adf116691e8.png" alt="weird symbol" widht=400>
</p>

Each flip-flop in the diagram is implemented with half of a 74HC74 chip. Bear in mind that each chip's set and reset inputs are *active-low*. This means that the "ResetN" signal is normally high. It goes low, when the button is pressed, to initialize the system. The active-low set and reset signals are the only difference between the physical circuit you build and the one you simulated with Verilog.

The clock and reset push button circuitry is the same as that of lab 9. You should be able to directly reuse it.

### Tips for building your circuit

You should plan your circuit before starting to wire it up. Build it incrementally. First, wire the R-C circuit and the clock button. Use a spare Schmitt-trigger inverter with a LED with a 150Ω series resistor and a long wire as a logic probe. You can use this to test any signal.

<p align=center>
  <img src="https://user-images.githubusercontent.com/37441514/160922809-ad96fc5f-32da-4ccc-b009-2d330b4fb213.png" alt="logic probe" width=500>
</p>

Next, connect the inverter output to the clock input of each of the three flip-flops. Connect LEDs and series resistors to the Q output of each flip-flop.

Next, each flip-flop should have a single unused S and R input. Wire each one high with the resistor as explained above.

Next, connect the useful S and R inputs of each flip-flop to the reset button. Use the logic probe to make sure that the reset signal is normally high and goes low when the reset button is pressed. Pressing the reset button should force the flip-flops into the specified reset state.

Next, connect the flip-flop outputs to the 74HC138 select inputs, A2, A1, and A0. When the E1, E2, and E3 input are connected appropriately to enable the decoder, the Y<sub>x</sub> output that corresponds to the reset value of your state machine should be active (low) when the reset button is pressed.

Next, connect the appropriate Y<sub>x</sub> outputs to the AND and NAND inputs to implement the next-state logic.

Finally, connect each NAND gate output to the appropriate flip-flop D input. Check that your circuit works as expected. In particular, ensure that pressing the clock button eight times completes a full cycle through all eight possible state values and winds up back at the original value.

## Step 2: Test your circuit

Once your circuit works, connect your AD2 to the *test points* labeled in the circuit diagram as follows:

- DIO 0: ResetN
- DIO 1: ClkN
- DIO 2: Q0
- DIO 3: Q1
- DIO 4: Q2
- DIO 5: NEXT_Q0
- DIO 6: NEXT_Q1
- DIO 7: NEXT_Q2

And ensure that the power and ground of the supply is connected to the appropriate power rails. You might manually test the inputs using the StaticIO tool. Once you have the circuit working as expected, use [Autolab](lab10.win.labtest) to produce a confirmation code.

When Autolab runs, it will report the status of three testcases that do the following operations:

- TC1: (20 points) Assert and deassert reset, then do a full state machine traversal by strobing the clock.
- TC2: (40 points) Try a full state machine traversal while the reset is asserted. The expectation is that it will stay in the reset state the entire time. This is actually the simplest test, so we'll put most of the points on this one to encourage you to make it work first.
- TC3: (20 points) Assert and deassert reset to put the state machine in the reset state, toggle the clock until a particular state is reached, then assert/deassert reset and check the next state. This checks to make sure that the reset and clock are really doing the right things.

## Step 3: Submit your confirmation code

Once you have a completion code that indicates the quality of your work, upload it to the postlab page.
